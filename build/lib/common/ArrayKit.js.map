{"version":3,"file":"ArrayKit.js","sourceRoot":"","sources":["../../../../src/common/ArrayKit.ts"],"names":[],"mappings":"AAEA;IAAA;IAgDA,CAAC;IA/CU,YAAG,GAAV,UAAW,OAAiB;QACxB,OAAO,OAAO,CAAC,MAAM,CAAC,UAAC,WAAW,EAAE,YAAY,IAAK,OAAA,WAAW,GAAG,YAAY,EAA1B,CAA0B,EAAE,CAAC,CAAC,CAAC;IACxF,CAAC;IAEM,iBAAQ,GAAf,UAAmB,KAAU,EAAE,GAA0B;QACrD,IAAI,GAAG,GAAG,CAAC,CAAC;QACZ,KAAK,CAAC,OAAO,CAAC,UAAA,CAAC;YACX,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE;gBACR,GAAG,GAAG,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;aAC7C;QACL,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;IACf,CAAC;IAEM,kBAAS,GAAhB,UAAoB,KAAU,EAAE,GAA0B,EAAE,KAAqB;QAC7E,OAAO,KAAK,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;YACnB,IAAM,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;YACjC,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5E,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,iBAAQ,GAAf,UAAmB,MAAc,EAAE,SAAqC;QACpE,IAAM,MAAM,GAAQ,EAAE,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC7B,MAAM,CAAC,IAAI,CAAC,OAAO,SAAS,KAAK,UAAU,CAAC,CAAC,CAAE,SAAkC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;SACrG;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,oBAAW,GAAlB,UAAyB,KAAU,EAAE,cAAuD;QACxF,IAAM,MAAM,GAAuB,EAAE,CAAC;QACtC,KAAK,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,KAAK;YACtB,IAAM,QAAQ,GAAG,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC7C,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,0BAAiB,GAAxB,UAAyF,OAAiB;QACtG,IAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG,IAAI,OAAA,MAAM,CAAC,IAAI,CAAC,GAAa,CAAC,EAA1B,CAA0B,CAAC,CAAC;QAClE,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,wBAAe,GAAtB,UAA0B,CAAM,EAAE,CAAM;QACpC,OAAO,CAAC,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAb,CAAa,CAAC,CAAC;IACtC,CAAC;IACL,eAAC;AAAD,CAAC,AAhDD,IAgDC","sourcesContent":["import {KeysOfType} from \"../type\";\n\nexport class ArrayKit {\n    static sum(numbers: number[]): number {\n        return numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n    }\n\n    static sumByKey<T>(array: T[], key: KeysOfType<T, number>): number {\n        let sum = 0;\n        array.forEach(_ => {\n            if (_[key]) {\n                sum = sum + parseFloat(_[key].toString());\n            }\n        });\n        return sum;\n    }\n\n    static sortByKey<T>(array: T[], key: KeysOfType<T, number>, order: \"asc\" | \"desc\"): T[] {\n        return array.sort((a, b) => {\n            const isLarger = a[key] > b[key];\n            return isLarger ? (order === \"asc\" ? 1 : -1) : order === \"asc\" ? -1 : 1;\n        });\n    }\n\n    static generate<T>(length: number, generator: T | ((index: number) => T)): T[] {\n        const result: T[] = [];\n        for (let i = 0; i < length; i++) {\n            result.push(typeof generator === \"function\" ? (generator as (index: number) => T)(i) : generator);\n        }\n        return result;\n    }\n\n    static mapToObject<T, V>(array: T[], mapperCallback: (item: T, index: number) => [string, V]): {[key: string]: V} {\n        const result: {[key: string]: V} = {};\n        array.forEach((item, index) => {\n            const mappedKV = mapperCallback(item, index);\n            result[mappedKV[0]] = mappedKV[1];\n        });\n        return result;\n    }\n\n    static mapFromStringEnum<EnumType extends {[P in keyof EnumType]: EnumType[P] & string}>(enumMap: EnumType): string[] {\n        const result: string[] = [];\n        Object.values(enumMap).forEach(key => result.push(key as string));\n        return result;\n    }\n\n    static hasIntersection<T>(a: T[], b: T[]): boolean {\n        return a.some(_ => b.includes(_));\n    }\n}\n"]}