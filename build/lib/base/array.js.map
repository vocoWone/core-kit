{"version":3,"file":"array.js","sourceRoot":"","sources":["../../../../src/base/array.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,GAAG,CAAC,OAAiB;IACjC,OAAO,OAAO,CAAC,MAAM,CAAC,UAAC,WAAW,EAAE,YAAY,IAAK,OAAA,WAAW,GAAG,YAAY,EAA1B,CAA0B,EAAE,CAAC,CAAC,CAAC;AACxF,CAAC;AAED,MAAM,UAAU,QAAQ,CAAI,KAAU,EAAE,GAA0B;IAC9D,IAAI,GAAG,GAAG,CAAC,CAAC;IACZ,KAAK,CAAC,OAAO,CAAC,UAAA,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE;YACR,GAAG,GAAG,GAAG,GAAG,UAAU,CAAC,CAAC,CAAC,GAAa,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;SACvD;IACL,CAAC,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;AACf,CAAC;AAED,MAAM,UAAU,SAAS,CAAI,KAAU,EAAE,GAA0B,EAAE,KAAqB;IACtF,OAAO,KAAK,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;QACnB,IAAM,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACjC,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5E,CAAC,CAAC,CAAC;AACP,CAAC;AAED,MAAM,UAAU,SAAS,CAAI,MAAc,EAAE,SAAwC;IACjF,IAAM,MAAM,GAAQ,EAAE,CAAC;IACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;QAC7B,MAAM,CAAC,IAAI,CAAC,OAAO,SAAS,KAAK,UAAU,CAAC,CAAC,CAAE,SAAkC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;KACrG;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AAED,OAAO;AACP,MAAM,UAAU,cAAc,CAAO,KAAU,EAAE,cAAuD,IAAG,CAAC;AAE5G,MAAM,UAAU,SAAS,CAAO,KAAU,EAAE,cAAuD;IAC/F,IAAM,MAAM,GAAuB,EAAE,CAAC;IACtC,KAAK,CAAC,OAAO,CAAC,UAAC,IAAI,EAAE,KAAK;QACtB,IAAM,QAAQ,GAAG,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC7C,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;IACtC,CAAC,CAAC,CAAC;IACH,OAAO,MAAM,CAAC;AAClB,CAAC;AAED,MAAM,UAAU,eAAe,CAAI,CAAM,EAAE,CAAM;IAC7C,OAAO,CAAC,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAb,CAAa,CAAC,CAAC;AACtC,CAAC","sourcesContent":["import {KeysOfType, FunctionType} from \"../type\";\n\nexport function sum(numbers: number[]): number {\n    return numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\n}\n\nexport function sumByKey<T>(array: T[], key: KeysOfType<T, number>): number {\n    let sum = 0;\n    array.forEach(_ => {\n        if (_[key]) {\n            sum = sum + parseFloat(_[key as number].toString());\n        }\n    });\n    return sum;\n}\n\nexport function sortByKey<T>(array: T[], key: KeysOfType<T, number>, order: \"asc\" | \"desc\"): T[] {\n    return array.sort((a, b) => {\n        const isLarger = a[key] > b[key];\n        return isLarger ? (order === \"asc\" ? 1 : -1) : order === \"asc\" ? -1 : 1;\n    });\n}\n\nexport function fillArray<T>(length: number, generator: T | FunctionType<number[], T>): T[] {\n    const result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result.push(typeof generator === \"function\" ? (generator as (index: number) => T)(i) : generator);\n    }\n    return result;\n}\n\n// TODO\nexport function eachArrayByKey<T, V>(array: T[], mapperCallback: (item: T, index: number) => [string, V]) {}\n\nexport function eachArray<T, V>(array: T[], mapperCallback: (item: T, index: number) => [string, V]): {[key: string]: V} {\n    const result: {[key: string]: V} = {};\n    array.forEach((item, index) => {\n        const mappedKV = mapperCallback(item, index);\n        result[mappedKV[0]] = mappedKV[1];\n    });\n    return result;\n}\n\nexport function hasIntersection<T>(a: T[], b: T[]): boolean {\n    return a.some(_ => b.includes(_));\n}\n"]}